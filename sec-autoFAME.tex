\section{AutoFAME}
AutoFAME is capable of creating FAME1 and FAME5 level FPGA optimized designs given a base functional datapath specified in Chisel. This is equivalent of automatically transforming a FAME0 level design into a FAME1 or FAME5 level design. The tool performs the required circuit transformations on the Chisel internal node graph and leverages Chisel's elaboration steps to output the optimzed design as either a cycle accurate C++ emulator or as a Verilog source file. 

\subsection{FAME Introduction}
FAME, or FPGA Architecture Model Execution is a system for efficiently emulating digital circuits on a FPGA introduced in the \textit{A Case for FAME: FPGA Architecture Model Execution paper} \cite{FAME:2010}. The paper introduces a system in which the concept of the emulated digital circuit, hence known as the target machine, is separated from the concept of the digital circuit that does the emulation of the target machine, hence known as the host machine. By extension, in FAME, the concept of time passing in the target machine, hence known as target time, is separated from the concept of time passing in the host machine, hence known as host time. 

In naive FPGA emulation, the target machine and the host machine are the same digital circuit. the RTL specification of the target machine is mapped directly to an FPGA through vendor tools with no change in the logic design. Because the characteristics of a FPGA are sometimes significantly different from the characteristics of a ASIC in timing and area characteristics, it is desirable to use a modified implementation of the design to emulation on a FPGA.

Using FAME, large digital designs can be broken up into islands that talk to each other in a decoupled manner. The partitioned system maintains the same target time behavior as the original design even though the islands are communicating in a decoupled manner. Target time behavior is maintained in the following manner. The original design is partitioned by placing island boundaries across registers in the target machine. In the host machine, the target registers are replaced by FAME Registers, which are FIFOs that start with one enqueued token equal to the reset value of the target register it replaced. Every island only advances its target clock by one clock cycle if its input FAME Registers are not empty and its output FAME Registers are not full. On every advance of the target clock, each island consumes a token from its input FAME Registers and outputs a token to its output FAME Registers. Thus, the target clock can advance in a decoupled manner while still remaining functionally the same as the original design. The island boundaries can also be drawn across queues in the target machine. In that case the target queue is replaced with a FAME Queue, which functionally replicates the target queue, but contains additional logic that keeps track of what tokens are visible in the target queue at each target clock cycle.

\subsection{Input Datapath Restrictions}
\subsection{FAME1 Transform}
\subsection{FAME5 Transform}
